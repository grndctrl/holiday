/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useRef, useState, useEffect } from 'react';
import { Box, useGLTF, shaderMaterial, Html } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useStore } from '../helpers/store';
import { useSpring, config, animated } from '@react-spring/three';
import { useFrame, extend } from '@react-three/fiber';
import ShaderPlane from './ShaderPlane';
import { useControls } from 'leva';
import { Vector3 } from 'three';
import next from 'next';
import { easeBounceInOut, easeElasticInOut, easeExpInOut, easeSinInOut } from 'd3-ease';

type GLTFResult = GLTF & {
  nodes: {
    Top: THREE.Mesh;
    Color: THREE.Mesh;
    TopScreen: THREE.Mesh;
    Bottom: THREE.Mesh;
    BottomScreen: THREE.Mesh;
    Cylinder: THREE.Mesh;
  };
  materials: {
    Material: THREE.MeshStandardMaterial;
  };
};

export default function Model({ ...props }) {
  const group = useRef<THREE.Group>();
  const indicator = useRef<THREE.MeshPhysicalMaterial>();
  const html = useRef<any>();
  const top = useRef<THREE.Group>();
  const light = useRef<THREE.DirectionalLight>();
  const materialTop = useRef<THREE.ShaderMaterial>();
  const bottom = useRef<THREE.Group>();
  const materialBottom = useRef<THREE.ShaderMaterial>();
  const { nodes, materials } = useGLTF('/MagicBox.glb') as GLTFResult;
  const [ticker, setTicker] = useState<number>(0);

  const { isOpen, toggleOpen } = useStore();
  const { isActive, toggleActive } = useStore();

  const [spring, api] = useSpring(() => ({
    position: [0, 0, 0],
    rotation: [0, Math.PI * 0.5, 0],
  }));

  const [springTop, apiTop] = useSpring(() => ({
    rotation: [0, 0, 0],
  }));

  const { opacity } = useSpring({ opacity: isActive ? 1 : 0 });

  const [colorA, setColorA] = useState<THREE.Color>(new THREE.Color().setHSL(Math.random() * 0.5, 0.5, 0.5));
  const [colorB, setColorB] = useState<THREE.Color>(new THREE.Color().setHSL(Math.random() * 0.5 + 0.5, 0.5, 0.5));
  const [colorI, setColorI] = useState<THREE.Color>(new THREE.Color().setHSL(Math.random() * 0.5 + 0.5, 0.5, 0.5));
  const [isFirst, toggleFirst] = useState<boolean>(true);

  const [springColor, apiColor] = useSpring(() => ({ customColor: [colorI.r, colorI.g, colorI.b] }));

  const handleClick = () => {
    toggleActive(!isActive);
  };

  useEffect(() => {
    if (isActive) {
      api.stop();
      api.start({
        position: [0.3, 1.5, 0],
        rotation: [Math.PI * 0.25, Math.PI * 0.15, Math.PI * -0.25],
        config: config.gentle,
      });
    } else {
      toggleOpen(false);

      api.stop();
      api.start({ position: [0, 0, 0], rotation: [0, Math.PI * 0.5, 0], config: config.slow });
      apiTop.stop();
      apiTop.start({ rotation: [0, 0, 0] });
    }
  }, [isActive]);

  // useEffect(() => {
  //   setLight
  // }, [isOpen]);

  const { intensity } = useSpring({ intensity: isOpen ? 0.1 : 1.0, config: config.molasses });

  const handleOpen = () => {
    toggleOpen(true);
    api.stop();
    apiTop.stop();
    api.start({ position: [0, 1, 0], rotation: [Math.PI * 0.4, Math.PI * 0.5, 0], config: config.slow });
    apiTop.start({ rotation: [0, 0, -Math.PI], config: config.slow });
  };

  const handleShake = () => {
    toggleOpen(false);

    api.start({
      to: async (next, cancel) => {
        await next({
          position: [0.3, 1.5, 0],
          rotation: [Math.PI * 0.25, Math.PI * 0.15, Math.PI * -0.25],
          config: config.gentle,
        });

        await next({
          position: [0.3, 1, 0],
          config: { duration: 200, easing: easeSinInOut },
        });

        await next({
          position: [0.3, 1.5, 0],
          config: { duration: 120, easing: easeSinInOut },
        });

        await next({
          position: [0.3, 1, 0],
          config: { duration: 120, easing: easeSinInOut },
        });

        await next({
          position: [0.3, 1.5, 0],
          config: { duration: 120, easing: easeSinInOut },
        });

        await next({
          position: [0.3, 1, 0],
          config: { duration: 120, easing: easeSinInOut },
        });

        await next({
          position: [0.3, 1.5, 0],
          config: config.wobbly,
        });
      },
    });
    apiTop.start({ rotation: [0, 0, 0] });

    // let hsl: any = null;
    // const hue = colorA.getHSL(hsl).h;
    setTimeout(() => {
      const random = Math.random();
      toggleFirst(false);
      setColorA(colorA.setHSL(random, 0.5, 0.25));
      setColorB(colorB.setHSL((random + 0.25) % 1.0, 0.5, 0.25));
      setColorI(colorI.setHSL(random, 1.0, 0.5));
      apiColor.start({ customColor: [colorI.r, colorI.g, colorI.b], config: config.slow });
      setTicker(ticker + 1);
      +0.5;
    }, 500);
  };

  useFrame((_, delta) => {
    if (group.current) {
      group.current.position.x = spring.position.get()[0];
      group.current.position.y = spring.position.get()[1];
      group.current.position.z = spring.position.get()[2];

      group.current.rotation.x = spring.rotation.get()[0];
      group.current.rotation.y = spring.rotation.get()[1];
      group.current.rotation.z = spring.rotation.get()[2];
    }

    if (top.current) {
      top.current.rotation.x = springTop.rotation.get()[0];
      top.current.rotation.y = springTop.rotation.get()[1];
      top.current.rotation.z = springTop.rotation.get()[2];
    }

    if (materialTop.current) {
      /* @ts-ignore */
      materialTop.current.time += delta * 0.75;
    }
    if (materialBottom.current) {
      /* @ts-ignore */
      materialBottom.current.time += delta * 0.75;
    }

    if (html.current) {
      html.current.style.opacity = opacity.get();
    }

    if (light.current) {
      light.current.intensity = intensity.get();
    }

    if (indicator.current) {
      indicator.current.color.r = springColor.customColor.get()[0];
      indicator.current.color.g = springColor.customColor.get()[1];
      indicator.current.color.b = springColor.customColor.get()[2];
    }
  });

  return (
    <>
      <directionalLight
        ref={light}
        castShadow
        position={[2, 8, -2]}
        shadow-mapSize-width={1024}
        shadow-mapSize-height={1024}
        shadow-camera-far={50}
        shadow-camera-left={-10}
        shadow-camera-right={10}
        shadow-camera-top={10}
        shadow-camera-bottom={-10}
      />
      {isActive && (
        <Html ref={html} position={[0, -0.5, 0]}>
          <div className="fixed flex w-screen pointer-events-none" style={{ left: '-50vw' }}>
            <div className="flex justify-end w-1/2">
              <button
                onClick={handleShake}
                className="p-3 m-8 text-lg text-white uppercase bg-black rounded-lg pointer-events-auto justify-self-start lg:p-4 lg:text-3xl"
              >
                SHAKE
              </button>
            </div>
            <div className="flex justify-start w-1/2">
              {!isOpen && !isFirst && (
                <button
                  onClick={handleOpen}
                  className="p-3 m-8 text-lg text-white uppercase bg-black rounded-lg pointer-events-auto justify-self-end lg:p-4 lg:text-3xl"
                >
                  OPEN
                </button>
              )}
            </div>
          </div>
        </Html>
      )}
      <group ref={group} dispose={null}>
        <Box args={[2, 1, 2]} onClick={handleClick} visible={false} />

        <mesh ref={top} castShadow geometry={nodes.Top.geometry}>
          <meshPhysicalMaterial color={'#2d343b'} roughness={0.8} metalness={0.1} />
          <mesh geometry={nodes.Color.geometry} position={[-0.5, -0.5, 0]}>
            <meshPhysicalMaterial ref={indicator} roughness={0.8} metalness={0.1} />
          </mesh>

          <ShaderPlane
            ticker={ticker}
            flipped={false}
            position={new THREE.Vector3(-0.45, 0, 0)}
            rotation={new THREE.Vector3(Math.PI * 0.5, 0, Math.PI * 0.5)}
            speed={0.75}
            a={colorA}
            b={colorB}
            c={colorA}
          />
        </mesh>
        <mesh ref={bottom} castShadow geometry={nodes.Bottom.geometry} material={nodes.Bottom.material}>
          <meshPhysicalMaterial color={'#2d343b'} roughness={0.8} metalness={0.1} />
          <ShaderPlane
            ticker={ticker}
            flipped={true}
            rotation={new THREE.Vector3(Math.PI * -0.5, 0, -Math.PI * 0.5)}
            position={new THREE.Vector3(-0.45, 0, 0)}
            speed={0.75}
            a={colorA}
            b={colorB}
            c={colorA}
          />
        </mesh>
        <mesh geometry={nodes.Cylinder.geometry} rotation={[Math.PI / 2, 0, 0]}>
          <meshPhysicalMaterial color={'#aec9e4'} roughness={0.8} metalness={0.1} />
        </mesh>
      </group>
    </>
  );
}

useGLTF.preload('/MagicBox.glb');
